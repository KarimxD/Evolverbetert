-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package Evolverbetert
@version 0.1.0.0

module Parameters
type Time = Int
type Prob = Double
defaultOutputFile :: [Char]
width :: Int
height :: Int
display :: Bool
outputStep :: Time
outputTime :: Time -> Bool
worldBounds :: ((Int, Int), (Int, Int))
worldCoods :: [(Int, Int)]
maxTime :: Int
devTime :: Int
selectionPressure :: Int
deathRate :: Prob
envSwitchProb :: Prob
nrEnv :: Int
nrGeneTypes :: Int
nrHouseHold :: Int
nrOverlap :: Int
nrSpecific :: Int
minThres :: Int
maxThres :: Int
pGenDel :: Prob
pGenDup :: Prob
pGenThresCh :: Prob
pTfbsWtCh :: Prob
pTfbsPrefCh :: Prob
pTfbsDel :: Prob
pTfbsInnov :: Prob
pTfbsDup :: Prob

module MyRandom
type Rand = State PureMT

-- | <a>PureMT</a>, a pure mersenne twister pseudo-random number generator
data PureMT :: *
runRand :: State PureMT a -> PureMT -> (a, PureMT)
getModifyRand :: Rand PureMT
evalRand :: State PureMT a -> PureMT -> a
getBool :: Rand Bool
getDouble :: Rand Double
getRange :: (Int, Int) -> Rand Int
getMyStdRandom :: (PureMT -> (a, PureMT)) -> IO a
setMyStdGen :: PureMT -> IO ()

-- | Gets the global random number generator.
getMyStdGen :: IO PureMT
randomBool :: PureMT -> (Bool, PureMT)

-- | Module : System.Random.Mersenne.Pure64 Copyright : Copyright (c) 2008,
--   Don Stewart <a>dons@galois.com</a> License : BSD3 Maintainer : Don
--   Stewart <a>dons@galois.com</a> Stability : experimental Portability:
--   CPP, FFI Tested with: GHC 6.8.3
--   
--   A purely functional binding 64 bit binding to the classic mersenne
--   twister random number generator. This is more flexible than the impure
--   'mersenne-random' library, at the cost of being a bit slower. This
--   generator is however, many times faster than System.Random, and yields
--   high quality randoms with a long period.
--   
--   This generator may be used with System.Random, however, that is likely
--   to be slower than using it directly.
--   
--   Create a PureMT generator from an Integral seed.
pureMT :: Integral a => a -> PureMT
instance System.Random.RandomGen System.Random.Mersenne.Pure64.Internal.PureMT

module Misc
valueResultPairs :: (a -> b) -> [a] -> [(a, b)]
maybeCh :: a -> (a -> Rand a) -> Double -> Rand a
moore8 :: (Int, Int) -> [(Int, Int)]

-- | Repeats a monadic operation n times collecting the results
repeatCollect :: Monad m => Int -> (a -> m a) -> a -> m a

module World
type Env = Int
data World
World :: Agents -> Env -> World
[agents] :: World -> Agents
[env] :: World -> Env
type Agents = Array (Int, Int) Agent
data Agent
Agent :: Genome -> GeneStateTable -> Agent
[genome] :: Agent -> Genome
[geneStateTable] :: Agent -> GeneStateTable
NoAgent :: Agent
type Genome = [Chromosome]
type Chromosome = [Locus]
type GeneStateTable = Map ID GeneState
showGST :: GeneStateTable -> String
data Locus
Transposon :: Locus
CGene :: Gene -> Locus
CTfbs :: Tfbs -> Locus
parseLoc :: [Char] -> Locus
data Gene
Gene :: ID -> Thres -> GeneState -> Gene
[iD] :: Gene -> ID
[thres] :: Gene -> Thres
[genSt] :: Gene -> GeneState
data Tfbs
Tfbs :: ID -> Weight -> Tfbs
type ID = Int
type Thres = Int
type GeneState = Int
type Weight = Int
devAg :: Agent -> Agent
sameGST :: Agent -> Agent -> Bool
defaultGst :: Map ID GeneState

-- | Check if locus is effected by expressed transcription factors | Return
--   the effect it has. 0 is no effect.
locusEffect :: Locus -> GeneStateTable -> Int
updateAgent :: Agent -> Agent
updateGenome :: GeneStateTable -> Genome -> Genome
updateChrom :: Int -> GeneStateTable -> Chromosome -> Chromosome
updateLoc :: Int -> GeneStateTable -> Locus -> (Int, Locus)
isGene :: Locus -> Bool

-- | e.g. [TF, TF, Gene, TF, Gene, TF] -&gt; [[TF, TF, Gene], [TF, Gene],
--   [TF]]
groupGeneTfbs :: [Locus] -> [[Locus]]
takeWhileInclusive :: (a -> Bool) -> ([a], [a]) -> ([a], [a])

-- | Generate GST from a genome
gSTFromGenome :: Genome -> GeneStateTable
makeGst :: GeneStateTable -> [Gene] -> GeneStateTable

-- | Concatinate chromosomes and trim them of non-coding genes fix for
--   genomes with more genes
reduceToTfbss :: Genome -> [Tfbs]
reduceToGenes :: Genome -> [Gene]
fitnessAgent :: Agent -> Env -> Double

-- | Uses targetGST to check fitness of passed GST
fitnessGST :: Env -> GeneStateTable -> Double
hammDist :: (Eq a) => [a] -> [a] -> Int
hammDistAg :: Agent -> Env -> Int

-- | Generate GeneStateTable based on targetExpression
targetGST :: Env -> GeneStateTable

-- | example for nrEnv = 4 and nrHousInteractionType0 1 0 1 0 0 0 2 1 1 1 1
--   1 1 0 0 0 1 0 0 3 1 1 1 1 0 1 1 0 0 0 1 0
targetExpression :: Env -> ID -> Int
agent0 :: Agent
randomAgent :: Rand Agent
connected :: Genome -> Bool
goodRandomGenome :: Rand Genome
randomGenome :: Rand Genome
randomChromosome :: Rand Chromosome
randomTfbs :: Rand [Locus]
randomGene :: Rand [Locus]
instance GHC.Classes.Ord World.Agent
instance GHC.Classes.Eq World.Agent
instance GHC.Read.Read World.Agent
instance GHC.Show.Show World.Agent
instance GHC.Read.Read World.Locus
instance GHC.Classes.Ord World.Locus
instance GHC.Classes.Eq World.Locus
instance GHC.Classes.Ord World.Tfbs
instance GHC.Classes.Eq World.Tfbs
instance GHC.Read.Read World.Tfbs
instance GHC.Show.Show World.Tfbs
instance GHC.Classes.Eq World.Gene
instance GHC.Read.Read World.Gene
instance GHC.Show.Show World.Gene
instance GHC.Show.Show World.Locus
instance GHC.Classes.Ord World.Gene

module Mutations
mutAg :: Agent -> Rand Agent

module MyGraphics
showWorld :: IORef World -> IO ()

module Evolverbetert

-- | Maybe initializes graphical display dependent on <a>display</a> in
--   <a>Parameters</a> calls <a>initialize</a> starts <a>mainLoop</a>
main :: IO ()
instance GHC.Show.Show Evolverbetert.Flag
instance GHC.Classes.Ord Evolverbetert.Flag
instance GHC.Classes.Eq Evolverbetert.Flag
